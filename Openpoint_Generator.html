<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OPENPOINT â€” Chamfer Export</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js"></script>

  <style>
    :root{
      --panel:#9bb400;       /* mockup green */
      --panelDark:#5f6c00;   /* darker green for buttons */
      --panelDarker:#4e5900; /* pressed/active */
      --ink:#263000;
      --bg:#d9ddcf;          /* light grey-green */
      --artboard:#dfe4d5;
      --stroke:#2a2a2a;
      --muted: rgba(0,0,0,0.55);
      --radius: 22px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      overflow:hidden;
    }

    /* App layout: left canvas area + right panel */
    .app{
      height:100vh;
      width:100vw;
      display:grid;
      grid-template-columns: 1fr 420px;
    }

    /* Left: p5 canvas mounts here */
    .stage{
      position:relative;
      overflow:hidden;
      background: var(--bg);
    }
    /* p5 injects canvas into body; we re-parent it */
    #p5-holder{
      position:absolute;
      inset:0;
    }

    /* Right panel */
    .panel{
      background: var(--panel);
      padding: 26px 26px 22px 26px;
      display:flex;
      flex-direction:column;
      gap: 18px;
    }

    .brand{
      display:flex;
      justify-content:flex-end;
      align-items:flex-start;
      padding-top: 4px;
    }
    .brand img{
      width: 240px;
      max-width: 100%;
      height:auto;
      display:block;
      filter: drop-shadow(0 1px 0 rgba(0,0,0,0.08));
    }

    .sectionTitle{
      text-align:center;
      letter-spacing:0.12em;
      font-size: 12px;
      color: rgba(0,0,0,0.55);
      margin-top: 2px;
      margin-bottom: -4px;
    }

    .formatRow{
      display:flex;
      justify-content:center;
      gap: 14px;
      padding: 6px 0 10px 0;
    }

    .fmt{
      width: 78px;
      height: 58px;
      border-radius: 10px;
      border: 0;
      cursor:pointer;
      background: rgba(0,0,0,0.45);
      color: rgba(255,255,255,0.92);
      font-size: 12px;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      user-select:none;
    }
    .fmt[data-aspect="1:1"]{ width:58px; }
    .fmt[data-aspect="4:5"]{ width:62px; height:78px; }
    .fmt[data-aspect="9:16"]{ width:58px; height:96px; }
    .fmt[data-aspect="16:9"]{ width:96px; height:54px; }

    .fmt.active{
      background: rgba(0,0,0,0.60);
      outline: 2px solid rgba(255,255,255,0.35);
      outline-offset: 2px;
    }

    .divider{
      height: 2px;
      width: 54px;
      margin: 4px auto 0 auto;
      background: rgba(0,0,0,0.25);
      border-radius:999px;
    }

    .controlBlock{
      display:flex;
      flex-direction:column;
      gap: 10px;
      padding: 6px 6px 0 6px;
    }

    .labelRow{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 10px;
      color: rgba(0,0,0,0.60);
      letter-spacing:0.12em;
      font-size: 12px;
    }

    .sliderWrap{
      position:relative;
      padding: 0 8px;
    }

    input[type="range"]{
      width:100%;
      -webkit-appearance:none;
      appearance:none;
      height: 4px;
      border-radius:999px;
      background: rgba(0,0,0,0.35);
      outline:none;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width: 22px;
      height: 22px;
      border-radius:999px;
      background: rgba(0,0,0,0.75);
      border: 2px solid rgba(255,255,255,0.25);
      cursor:pointer;
      margin-top: -9px;
    }
    input[type="range"]::-moz-range-thumb{
      width: 22px;
      height: 22px;
      border-radius:999px;
      background: rgba(0,0,0,0.75);
      border: 2px solid rgba(255,255,255,0.25);
      cursor:pointer;
    }

    .bubble{
      position:absolute;
      top: -34px;
      transform: translateX(-50%);
      min-width: 44px;
      padding: 6px 10px;
      border-radius:999px;
      background: rgba(0,0,0,0.70);
      color: rgba(255,255,255,0.92);
      font-size: 12px;
      text-align:center;
      pointer-events:none;
      box-shadow: 0 6px 18px rgba(0,0,0,0.18);
    }

    .btn{
      width: 100%;
      border: 0;
      border-radius: 16px;
      padding: 18px 16px;
      cursor:pointer;
      background: rgba(0,0,0,0.55);
      color: rgba(255,255,255,0.92);
      letter-spacing:0.05em;
      font-weight: 600;
    }
    .btn:hover{ background: rgba(0,0,0,0.62); }
    .btn:active{ background: rgba(0,0,0,0.70); }

    .btnRow{
      display:flex;
      flex-direction:column;
      gap: 14px;
      margin-top: 8px;
    }

    /* Hidden file input, styled button triggers it */
    #file{
      position:absolute;
      left:-9999px;
      width:1px;height:1px;
    }

    /* small footer hint (optional) */
    .hint{
      margin-top:auto;
      font-size: 12px;
      color: rgba(0,0,0,0.55);
      line-height:1.35;
      padding: 4px 6px 0 6px;
    }

    @media (max-width: 980px){
      .app{ grid-template-columns: 1fr; }
      .panel{ height: 420px; }
      body{ overflow:auto; }
      .stage{ height: calc(100vh - 420px); min-height: 420px; }
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="stage">
      <div id="p5-holder"></div>
    </div>

    <aside class="panel">
      <div class="brand">
        <!-- logo asset: place OPENPOINT.svg next to this html -->
        <img src="./OPENPOINT.svg" alt="OPENPOINT" />
      </div>

      <div class="sectionTitle">FORMAT</div>
      <div class="formatRow">
        <button class="fmt active" data-aspect="1:1"  title="Square">1X1</button>
        <button class="fmt"        data-aspect="4:5"  title="Portrait 4:5">4X5</button>
        <button class="fmt"        data-aspect="9:16" title="Portrait 9:16">9X16</button>
        <button class="fmt"        data-aspect="16:9" title="Landscape 16:9">16X9</button>
      </div>

      <div class="divider"></div>

      <div class="controlBlock">
        <div class="labelRow">CHAMFER</div>
        <div class="sliderWrap">
          <div id="chBubble" class="bubble">40</div>
          <input id="chamfer" type="range" min="0" max="250" value="40" />
        </div>
      </div>

      <div class="controlBlock">
        <div class="labelRow">CURVE</div>
        <div class="sliderWrap">
          <div id="cvBubble" class="bubble">60</div>
          <input id="curve" type="range" min="0" max="100" value="60" />
        </div>
      </div>

      <div class="divider"></div>

      <div class="btnRow">
        <input id="file" type="file" accept="image/*" />
        <button id="uploadBtn" class="btn">UPLOAD IMAGE</button>
        <button id="exportBtn" class="btn">EXPORT PNG</button>
      </div>

      <div class="hint">
        Drag to reposition. Wheel/trackpad to zoom.<br>
        Export includes a 50px margin.
      </div>
    </aside>
  </div>

  <script>
    // --------- State ----------
    let img = null;

    // Right panel UI
    let fileInput, uploadBtn, exportBtn;
    let chamferSlider, curveSlider;
    let chBubble, cvBubble;
    let formatButtons;

    // Artboard format (aspect ratio)
    const formats = {
      "1:1":  { w: 1,  h: 1  },
      "4:5":  { w: 4,  h: 5  },
      "9:16": { w: 9,  h: 16 },
      "16:9": { w: 16, h: 9  }
    };
    let currentFormat = "1:1";

    // View controls (pan/zoom inside artboard)
    let zoom = 1;
    let pan = { x: 0, y: 0 };
    let dragging = false;
    let lastMouse = { x: 0, y: 0 };

    // Computed preview artboard rect (in canvas pixels)
    let art = { x: 0, y: 0, w: 100, h: 100 };

    // --------- p5 ----------
    function setup() {
      const holder = document.getElementById("p5-holder");
      const c = createCanvas(holder.clientWidth, holder.clientHeight);
      c.parent(holder);
      pixelDensity(2);

      // UI
      fileInput = document.getElementById("file");
      uploadBtn = document.getElementById("uploadBtn");
      exportBtn = document.getElementById("exportBtn");

      chamferSlider = document.getElementById("chamfer");
      curveSlider = document.getElementById("curve");
      chBubble = document.getElementById("chBubble");
      cvBubble = document.getElementById("cvBubble");

      formatButtons = Array.from(document.querySelectorAll(".fmt"));

      // Wire format buttons
      formatButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          formatButtons.forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          currentFormat = btn.dataset.aspect;
          resetViewToFit();
        });
      });

      // Upload
      uploadBtn.addEventListener("click", () => fileInput.click());
      fileInput.addEventListener("change", handleFile);

      // Sliders
      chamferSlider.addEventListener("input", () => {
        updateBubble(chamferSlider, chBubble, chamferSlider.value);
      });
      curveSlider.addEventListener("input", () => {
        updateBubble(curveSlider, cvBubble, curveSlider.value);
      });

      // Init bubble positions
      updateBubble(chamferSlider, chBubble, chamferSlider.value);
      updateBubble(curveSlider, cvBubble, curveSlider.value);

      // Export
      exportBtn.addEventListener("click", exportPNG);

      // Start centered
      pan.x = width / 2;
      pan.y = height / 2;

      computeArtboardRect();
      resetViewToFit();
    }

    function windowResized() {
      const holder = document.getElementById("p5-holder");
      resizeCanvas(holder.clientWidth, holder.clientHeight);
      computeArtboardRect();
      resetViewToFit();
    }

    function draw() {
      background(getComputedStyle(document.documentElement).getPropertyValue("--bg").trim());

      computeArtboardRect();

      // Draw artboard container (rounded rect)
      noStroke();
      fill(getComputedStyle(document.documentElement).getPropertyValue("--artboard").trim());
      drawRoundedRect(art.x, art.y, art.w, art.h, 18);

      // If no image, placeholder outline
      if (!img) {
        stroke(getComputedStyle(document.documentElement).getPropertyValue("--stroke").trim());
        strokeWeight(2);
        noFill();
        drawRoundedRect(art.x, art.y, art.w, art.h, 18);

        noStroke();
        fill(0, 90);
        textAlign(CENTER, CENTER);
        textSize(16);
        text("Upload an image", width/2, height/2 - 6);
        textSize(12);
        text("to preview + export", width/2, height/2 + 14);
        return;
      }

      // Clip to inward-curved chamfer path INSIDE the artboard
      const cPx = constrain(Number(chamferSlider.value), 0, Math.min(art.w, art.h) * 0.5);
      const curveK = Number(curveSlider.value) / 100;

      const ctx = drawingContext;
      ctx.save();
      applyInwardCurvedChamferClip(ctx, art.x, art.y, art.w, art.h, cPx, curveK);

      // Draw image with pan/zoom around artboard center
      // We treat pan as the image's center point in canvas coords
      const drawW = img.width * zoom;
      const drawH = img.height * zoom;
      const x = pan.x - drawW / 2;
      const y = pan.y - drawH / 2;
      image(img, x, y, drawW, drawH);

      ctx.restore();

      // Artboard outline
      drawInwardCurvedChamferOutline(ctx, art.x, art.y, art.w, art.h, cPx, curveK);
    }

    // --------- Artboard sizing ----------
    function computeArtboardRect(){
      const pad = 76;
      const maxW = Math.max(140, width - pad * 2);
      const maxH = Math.max(140, height - pad * 2);

      const f = formats[currentFormat];
      const aspect = f.w / f.h;

      let w = maxW;
      let h = w / aspect;

      if (h > maxH) {
        h = maxH;
        w = h * aspect;
      }

      art.w = w;
      art.h = h;
      art.x = (width - w) / 2;
      art.y = (height - h) / 2;
    }

    function resetViewToFit(){
      if (!img) {
        pan.x = width/2;
        pan.y = height/2;
        zoom = 1;
        return;
      }

      // Fit image so it covers the artboard (so the user can pan to frame)
      // cover = max(art.w/img.w, art.h/img.h)
      computeArtboardRect();
      const cover = Math.max(art.w / img.width, art.h / img.height);
      zoom = cover;

      // Center image on artboard
      pan.x = art.x + art.w/2;
      pan.y = art.y + art.h/2;

      // Adjust chamfer max relative to artboard
      const drawnMin = Math.min(art.w, art.h);
      chamferSlider.max = String(Math.max(50, Math.floor(drawnMin / 2)));
      chamferSlider.value = String(Math.min(Number(chamferSlider.value), Number(chamferSlider.max)));
      updateBubble(chamferSlider, chBubble, chamferSlider.value);
    }

    // --------- Upload ----------
    function handleFile(e) {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      const url = URL.createObjectURL(file);
      loadImage(url, (loaded) => {
        img = loaded;
        URL.revokeObjectURL(url);
        resetViewToFit();
      });
    }

    // --------- Export ----------
    function exportPNG(){
      if (!img) return;

      const margin = 50;

      // Determine "export artboard size" in ORIGINAL IMAGE PIXELS:
      // We compute an inscribed rectangle of the selected aspect inside the image.
      // User pan/zoom determines what part is shown.
      const f = formats[currentFormat];
      const aspect = f.w / f.h;

      let boardW, boardH;
      if ((img.width / img.height) >= aspect) {
        boardH = img.height;
        boardW = boardH * aspect;
      } else {
        boardW = img.width;
        boardH = boardW / aspect;
      }

      // Output size = artboard + margin
      const outW = Math.round(boardW + margin * 2);
      const outH = Math.round(boardH + margin * 2);

      const pg = createGraphics(outW, outH);
      pg.pixelDensity(1);

      // Flat background (no transparency option)
      pg.noStroke();
      pg.fill(getComputedStyle(document.documentElement).getPropertyValue("--artboard").trim());
      pg.rect(0, 0, outW, outH);

      // Convert current view (pan/zoom) into export-space transform.
      // We map the preview artboard rect -> export artboard rect.
      // Compute where the image center sits relative to preview artboard center:
      const previewCenterX = art.x + art.w/2;
      const previewCenterY = art.y + art.h/2;

      const dx = (pan.x - previewCenterX) / zoom; // in image pixels (because drawW = img.w*zoom)
      const dy = (pan.y - previewCenterY) / zoom;

      // In export, artboard center is at:
      const exCenterX = margin + boardW/2;
      const exCenterY = margin + boardH/2;

      // Place image so that same (dx,dy) offset applies:
      // image center = exportCenter + (dx,dy)
      const imgCenterX = exCenterX + dx;
      const imgCenterY = exCenterY + dy;

      // For export zoom scale: relate preview artboard size to export artboard size
      const scaleFactor = boardW / art.w; // (also equals boardH/art.h)
      const exportZoom = zoom * scaleFactor;

      const drawW = img.width * exportZoom;
      const drawH = img.height * exportZoom;
      const x = imgCenterX - drawW/2;
      const y = imgCenterY - drawH/2;

      // Chamfer in export pixels, scaled from preview chamfer
      const cPreview = constrain(Number(chamferSlider.value), 0, Math.min(art.w, art.h)*0.5);
      const cExport = cPreview * scaleFactor;
      const curveK = Number(curveSlider.value) / 100;

      // Clip to chamfered artboard and draw image
      const ctx = pg.drawingContext;
      ctx.save();
      applyInwardCurvedChamferClip(ctx, margin, margin, boardW, boardH, cExport, curveK);
      pg.image(img, x, y, drawW, drawH);
      ctx.restore();

      const outImg = pg.get();
      outImg.save("openpoint-export", "png");
      pg.remove();
    }

    // --------- Interaction (pan/zoom) ----------
    function mousePressed(){
      if (isMouseOverPanel()) return;
      if (!img) return;

      // only start drag if inside artboard area
      if (mouseX < art.x || mouseX > art.x + art.w || mouseY < art.y || mouseY > art.y + art.h) return;

      dragging = true;
      lastMouse.x = mouseX;
      lastMouse.y = mouseY;
    }

    function mouseDragged(){
      if (!dragging) return;
      pan.x += (mouseX - lastMouse.x);
      pan.y += (mouseY - lastMouse.y);
      lastMouse.x = mouseX;
      lastMouse.y = mouseY;
    }

    function mouseReleased(){
      dragging = false;
    }

    function mouseWheel(event){
      if (!img) return;
      if (isMouseOverPanel()) return;

      // zoom around cursor
      const zoomFactor = Math.pow(1.0015, -event.delta);
      const newZoom = constrain(zoom * zoomFactor, 0.05, 40);

      const mx = mouseX, my = mouseY;
      const dx = mx - pan.x;
      const dy = my - pan.y;
      const scale = newZoom / zoom;

      pan.x = mx - dx * scale;
      pan.y = my - dy * scale;
      zoom = newZoom;

      return false;
    }

    function isMouseOverPanel(){
      const panel = document.querySelector(".panel");
      const r = panel.getBoundingClientRect();
      return mouseX >= r.left && mouseX <= r.right && mouseY >= r.top && mouseY <= r.bottom;
    }

    // --------- UI bubble positioning ----------
    function updateBubble(slider, bubble, value){
      bubble.textContent = value;

      const min = Number(slider.min);
      const max = Number(slider.max);
      const v = Number(value);

      const pct = (v - min) / (max - min || 1);
      const trackW = slider.clientWidth;
      const thumb = 22; // matches CSS thumb
      const x = pct * (trackW - thumb) + thumb/2;

      bubble.style.left = `${x}px`;
    }

    // --------- Drawing helpers ----------
    function drawRoundedRect(x,y,w,h,r){
      // p5 rounded rect (manual for consistent look)
      beginShape();
      vertex(x+r, y);
      vertex(x+w-r, y);
      quadraticVertex(x+w, y, x+w, y+r);
      vertex(x+w, y+h-r);
      quadraticVertex(x+w, y+h, x+w-r, y+h);
      vertex(x+r, y+h);
      quadraticVertex(x, y+h, x, y+h-r);
      vertex(x, y+r);
      quadraticVertex(x, y, x+r, y);
      endShape(CLOSE);
    }

    function applyInwardCurvedChamferClip(ctx, x, y, w, h, c, k) {
      const t = constrain(k, 0, 1);
      const useCurve = t > 0.0001;
      const f = 0.5 + 0.5 * t; // 0.5..1

      ctx.beginPath();
      ctx.moveTo(x + c, y);

      ctx.lineTo(x + w - c, y);

      if (useCurve) {
        ctx.quadraticCurveTo(x + w - c * f, y + c * f, x + w, y + c);
      } else {
        ctx.lineTo(x + w, y + c);
      }

      ctx.lineTo(x + w, y + h - c);

      if (useCurve) {
        ctx.quadraticCurveTo(x + w - c * f, y + h - c * f, x + w - c, y + h);
      } else {
        ctx.lineTo(x + w - c, y + h);
      }

      ctx.lineTo(x + c, y + h);

      if (useCurve) {
        ctx.quadraticCurveTo(x + c * f, y + h - c * f, x, y + h - c);
      } else {
        ctx.lineTo(x, y + h - c);
      }

      ctx.lineTo(x, y + c);

      if (useCurve) {
        ctx.quadraticCurveTo(x + c * f, y + c * f, x + c, y);
      } else {
        ctx.lineTo(x + c, y);
      }

      ctx.closePath();
      ctx.clip();
    }

    function drawInwardCurvedChamferOutline(ctx, x, y, w, h, c, k) {
      const t = constrain(k, 0, 1);
      const useCurve = t > 0.0001;
      const f = 0.5 + 0.5 * t;

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(x + c, y);
      ctx.lineTo(x + w - c, y);

      if (useCurve) {
        ctx.quadraticCurveTo(x + w - c * f, y + c * f, x + w, y + c);
      } else {
        ctx.lineTo(x + w, y + c);
      }

      ctx.lineTo(x + w, y + h - c);

      if (useCurve) {
        ctx.quadraticCurveTo(x + w - c * f, y + h - c * f, x + w - c, y + h);
      } else {
        ctx.lineTo(x + w - c, y + h);
      }

      ctx.lineTo(x + c, y + h);

      if (useCurve) {
        ctx.quadraticCurveTo(x + c * f, y + h - c * f, x, y + h - c);
      } else {
        ctx.lineTo(x, y + h - c);
      }

      ctx.lineTo(x, y + c);

      if (useCurve) {
        ctx.quadraticCurveTo(x + c * f, y + c * f, x + c, y);
      } else {
        ctx.lineTo(x + c, y);
      }

      ctx.closePath();

      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(0,0,0,0.70)";
      ctx.stroke();
      ctx.restore();
    }
  </script>
</body>
</html>
